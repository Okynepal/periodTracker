var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var BlendMode;
(function(BlendMode2) {
  BlendMode2[BlendMode2["Normal"] = 0] = "Normal";
  BlendMode2[BlendMode2["Multiply"] = 1] = "Multiply";
  BlendMode2[BlendMode2["Screen"] = 2] = "Screen";
  BlendMode2[BlendMode2["Overlay"] = 3] = "Overlay";
  BlendMode2[BlendMode2["Darken"] = 4] = "Darken";
  BlendMode2[BlendMode2["Lighten"] = 5] = "Lighten";
  BlendMode2[BlendMode2["ColorDodge"] = 6] = "ColorDodge";
  BlendMode2[BlendMode2["ColorBurn"] = 7] = "ColorBurn";
  BlendMode2[BlendMode2["HardLight"] = 8] = "HardLight";
  BlendMode2[BlendMode2["SoftLight"] = 9] = "SoftLight";
  BlendMode2[BlendMode2["Difference"] = 10] = "Difference";
  BlendMode2[BlendMode2["Exclusion"] = 11] = "Exclusion";
  BlendMode2[BlendMode2["Hue"] = 12] = "Hue";
  BlendMode2[BlendMode2["Saturation"] = 13] = "Saturation";
  BlendMode2[BlendMode2["Color"] = 14] = "Color";
  BlendMode2[BlendMode2["Luminosity"] = 15] = "Luminosity";
})(BlendMode || (BlendMode = {}));
var MatteMode;
(function(MatteMode2) {
  MatteMode2[MatteMode2["Normal"] = 0] = "Normal";
  MatteMode2[MatteMode2["Alpha"] = 1] = "Alpha";
  MatteMode2[MatteMode2["InvertedAlpha"] = 2] = "InvertedAlpha";
  MatteMode2[MatteMode2["Luma"] = 3] = "Luma";
  MatteMode2[MatteMode2["InvertedLuma"] = 4] = "InvertedLuma";
})(MatteMode || (MatteMode = {}));
var Layer3DMode;
(function(Layer3DMode2) {
  Layer3DMode2[Layer3DMode2["Off"] = 0] = "Off";
  Layer3DMode2[Layer3DMode2["On"] = 1] = "On";
})(Layer3DMode || (Layer3DMode = {}));
var AutoOrientMode;
(function(AutoOrientMode2) {
  AutoOrientMode2[AutoOrientMode2["Off"] = 0] = "Off";
  AutoOrientMode2[AutoOrientMode2["On"] = 1] = "On";
})(AutoOrientMode || (AutoOrientMode = {}));
var EffectValueType;
(function(EffectValueType2) {
  EffectValueType2[EffectValueType2["Number"] = 0] = "Number";
  EffectValueType2[EffectValueType2["Color"] = 2] = "Color";
  EffectValueType2[EffectValueType2["MultiDimensional"] = 3] = "MultiDimensional";
  EffectValueType2[EffectValueType2["Boolean"] = 7] = "Boolean";
})(EffectValueType || (EffectValueType = {}));
var EffectType;
(function(EffectType2) {
  EffectType2[EffectType2["Transform"] = 5] = "Transform";
  EffectType2[EffectType2["DropShadow"] = 25] = "DropShadow";
})(EffectType || (EffectType = {}));
var MaskMode;
(function(MaskMode2) {
  MaskMode2["No"] = "n";
  MaskMode2["Add"] = "a";
  MaskMode2["Subtract"] = "s";
  MaskMode2["Intersect"] = "i";
  MaskMode2["Lighten"] = "l";
  MaskMode2["Darken"] = "d";
  MaskMode2["Difference"] = "f";
})(MaskMode || (MaskMode = {}));
var LayerType;
(function(LayerType2) {
  LayerType2[LayerType2["precomp"] = 0] = "precomp";
  LayerType2[LayerType2["solid"] = 1] = "solid";
  LayerType2[LayerType2["still"] = 2] = "still";
  LayerType2[LayerType2["null"] = 3] = "null";
  LayerType2[LayerType2["shape"] = 4] = "shape";
  LayerType2[LayerType2["text"] = 5] = "text";
  LayerType2[LayerType2["audio"] = 6] = "audio";
  LayerType2[LayerType2["pholderVideo"] = 7] = "pholderVideo";
  LayerType2[LayerType2["imageSeq"] = 8] = "imageSeq";
  LayerType2[LayerType2["video"] = 9] = "video";
  LayerType2[LayerType2["pholderStill"] = 10] = "pholderStill";
  LayerType2[LayerType2["guide"] = 11] = "guide";
  LayerType2[LayerType2["adjustment"] = 12] = "adjustment";
  LayerType2[LayerType2["camera"] = 13] = "camera";
  LayerType2[LayerType2["light"] = 14] = "light";
})(LayerType || (LayerType = {}));
var TextJustify;
(function(TextJustify2) {
  TextJustify2[TextJustify2["Left"] = 0] = "Left";
  TextJustify2[TextJustify2["Right"] = 1] = "Right";
  TextJustify2[TextJustify2["Center"] = 2] = "Center";
})(TextJustify || (TextJustify = {}));
var VerticalJustify;
(function(VerticalJustify2) {
  VerticalJustify2[VerticalJustify2["Top"] = 0] = "Top";
  VerticalJustify2[VerticalJustify2["Center"] = 1] = "Center";
  VerticalJustify2[VerticalJustify2["Bottom"] = 2] = "Bottom";
})(VerticalJustify || (VerticalJustify = {}));
var RangeSelectorDomain;
(function(RangeSelectorDomain2) {
  RangeSelectorDomain2[RangeSelectorDomain2["Characters"] = 1] = "Characters";
  RangeSelectorDomain2[RangeSelectorDomain2["CharactersExcludingSpaces"] = 2] = "CharactersExcludingSpaces";
  RangeSelectorDomain2[RangeSelectorDomain2["Words"] = 3] = "Words";
  RangeSelectorDomain2[RangeSelectorDomain2["Lines"] = 4] = "Lines";
})(RangeSelectorDomain || (RangeSelectorDomain = {}));
var RangeSelectorShape;
(function(RangeSelectorShape2) {
  RangeSelectorShape2[RangeSelectorShape2["Square"] = 1] = "Square";
  RangeSelectorShape2[RangeSelectorShape2["RampUp"] = 2] = "RampUp";
  RangeSelectorShape2[RangeSelectorShape2["RampDown"] = 3] = "RampDown";
  RangeSelectorShape2[RangeSelectorShape2["Triangle"] = 4] = "Triangle";
  RangeSelectorShape2[RangeSelectorShape2["Round"] = 5] = "Round";
  RangeSelectorShape2[RangeSelectorShape2["Smooth"] = 6] = "Smooth";
})(RangeSelectorShape || (RangeSelectorShape = {}));
var RangeSelectorUnits;
(function(RangeSelectorUnits2) {
  RangeSelectorUnits2[RangeSelectorUnits2["Percentage"] = 1] = "Percentage";
  RangeSelectorUnits2[RangeSelectorUnits2["Index"] = 2] = "Index";
})(RangeSelectorUnits || (RangeSelectorUnits = {}));
var RangeSelectorMode;
(function(RangeSelectorMode2) {
  RangeSelectorMode2[RangeSelectorMode2["Add"] = 1] = "Add";
  RangeSelectorMode2[RangeSelectorMode2["Subtract"] = 2] = "Subtract";
  RangeSelectorMode2[RangeSelectorMode2["Intersect"] = 3] = "Intersect";
  RangeSelectorMode2[RangeSelectorMode2["Min"] = 4] = "Min";
  RangeSelectorMode2[RangeSelectorMode2["Max"] = 5] = "Max";
  RangeSelectorMode2[RangeSelectorMode2["Difference"] = 6] = "Difference";
})(RangeSelectorMode || (RangeSelectorMode = {}));
var ShapeType;
(function(ShapeType2) {
  ShapeType2["Group"] = "gr";
  ShapeType2["Rect"] = "rc";
  ShapeType2["Ellipse"] = "el";
  ShapeType2["Fill"] = "fl";
  ShapeType2["GradientFill"] = "gf";
  ShapeType2["GradientStroke"] = "gs";
  ShapeType2["Stroke"] = "st";
  ShapeType2["Transform"] = "tr";
  ShapeType2["Path"] = "sh";
  ShapeType2["Repeat"] = "rp";
  ShapeType2["Trim"] = "tm";
})(ShapeType || (ShapeType = {}));
var FillRule;
(function(FillRule2) {
  FillRule2[FillRule2["NonZero"] = 1] = "NonZero";
  FillRule2[FillRule2["EvenOdd"] = 2] = "EvenOdd";
})(FillRule || (FillRule = {}));
var LineJoin;
(function(LineJoin2) {
  LineJoin2[LineJoin2["Miter"] = 1] = "Miter";
  LineJoin2[LineJoin2["Round"] = 2] = "Round";
  LineJoin2[LineJoin2["Bevel"] = 3] = "Bevel";
})(LineJoin || (LineJoin = {}));
var LineCap;
(function(LineCap2) {
  LineCap2[LineCap2["Butt"] = 1] = "Butt";
  LineCap2[LineCap2["Round"] = 2] = "Round";
  LineCap2[LineCap2["Square"] = 3] = "Square";
})(LineCap || (LineCap = {}));
var GradientType;
(function(GradientType2) {
  GradientType2[GradientType2["Linear"] = 1] = "Linear";
  GradientType2[GradientType2["Radial"] = 2] = "Radial";
})(GradientType || (GradientType = {}));
var FontPathOrigin;
(function(FontPathOrigin2) {
  FontPathOrigin2[FontPathOrigin2["CssUrl"] = 1] = "CssUrl";
  FontPathOrigin2[FontPathOrigin2["ScriptUrl"] = 2] = "ScriptUrl";
  FontPathOrigin2[FontPathOrigin2["FontUrl"] = 3] = "FontUrl";
})(FontPathOrigin || (FontPathOrigin = {}));
var DEFAULT_FONT_SIZE = 12;
var DEFAULT_FONT_FAMILY = "sans-serif";
var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
var OFFSET = 20;
var SCALE = 100;
var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(mapStr) {
  var map = {};
  if (typeof JSON === "undefined") {
    return map;
  }
  for (var i = 0; i < mapStr.length; i++) {
    var char = String.fromCharCode(i + 32);
    var size = (mapStr.charCodeAt(i) - OFFSET) / SCALE;
    map[char] = size;
  }
  return map;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
var platformApi = {
  createCanvas: function() {
    return typeof document !== "undefined" && document.createElement("canvas");
  },
  measureText: function() {
    var _ctx;
    var _cachedFont;
    return function(text, font) {
      if (!_ctx) {
        var canvas = platformApi.createCanvas();
        _ctx = canvas && canvas.getContext("2d");
      }
      if (_ctx) {
        if (_cachedFont !== font) {
          _cachedFont = _ctx.font = font || DEFAULT_FONT;
        }
        return _ctx.measureText(text);
      } else {
        text = text || "";
        font = font || DEFAULT_FONT;
        var res = /^([0-9]*?)px$/.exec(font);
        var fontSize = +(res && res[1]) || DEFAULT_FONT_SIZE;
        var width = 0;
        if (font.indexOf("mono") >= 0) {
          width = fontSize * text.length;
        } else {
          for (var i = 0; i < text.length; i++) {
            var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i]];
            width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
          }
        }
        return { width };
      }
    };
  }(),
  loadImage: function(src, onload, onerror) {
    var image = new Image();
    image.onload = onload;
    image.onerror = onerror;
    image.src = src;
    return image;
  }
};
var BUILTIN_OBJECT = reduce([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(obj, val) {
  obj["[object " + val + "]"] = true;
  return obj;
}, {});
var TYPED_ARRAY = reduce([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(obj, val) {
  obj["[object " + val + "Array]"] = true;
  return obj;
}, {});
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeSlice = arrayProto.slice;
var ctorFunction = function() {
}.constructor;
var protoFunction = ctorFunction ? ctorFunction.prototype : null;
var protoKey = "__proto__";
function clone(source) {
  if (source == null || typeof source !== "object") {
    return source;
  }
  var result = source;
  var typeStr = objToString.call(source);
  if (typeStr === "[object Array]") {
    if (!isPrimitive(source)) {
      result = [];
      for (var i = 0, len = source.length; i < len; i++) {
        result[i] = clone(source[i]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source)) {
      var Ctor = source.constructor;
      if (Ctor.from) {
        result = Ctor.from(source);
      } else {
        result = new Ctor(source.length);
        for (var i = 0, len = source.length; i < len; i++) {
          result[i] = source[i];
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};
    for (var key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        result[key] = clone(source[key]);
      }
    }
  }
  return result;
}
function merge(target, source, overwrite) {
  if (!isObject(source) || !isObject(target)) {
    return overwrite ? clone(source) : target;
  }
  for (var key in source) {
    if (source.hasOwnProperty(key) && key !== protoKey) {
      var targetProp = target[key];
      var sourceProp = source[key];
      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        merge(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        target[key] = clone(source[key]);
      }
    }
  }
  return target;
}
platformApi.createCanvas;
function reduce(arr, cb, memo, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i = 0, len = arr.length; i < len; i++) {
    memo = cb.call(context, memo, arr[i], i, arr);
  }
  return memo;
}
function bindPolyfill(func, context) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return function() {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function isArray(value) {
  if (Array.isArray) {
    return Array.isArray(value);
  }
  return objToString.call(value) === "[object Array]";
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  var type = typeof value;
  return type === "function" || !!value && type === "object";
}
function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
function isDom(value) {
  return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
}
var primitiveKey = "__ec_primitive__";
function isPrimitive(obj) {
  return obj[primitiveKey];
}
function distance(v1, v2) {
  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
}
var dist = distance;
function applyTransform(out, v, m) {
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function cubicSubdivide(p0, p1, p2, p3, t, out) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p23 = (p3 - p2) * t + p2;
  var p012 = (p12 - p01) * t + p01;
  var p123 = (p23 - p12) * t + p12;
  var p0123 = (p123 - p012) * t + p012;
  out[0] = p0;
  out[1] = p01;
  out[2] = p012;
  out[3] = p0123;
  out[4] = p0123;
  out[5] = p123;
  out[6] = p23;
  out[7] = p3;
}
function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
  var px = x0;
  var py = y0;
  var d = 0;
  var step = 1 / iteration;
  for (var i = 1; i <= iteration; i++) {
    var t = i * step;
    var x = cubicAt(x0, x1, x2, x3, t);
    var y = cubicAt(y0, y1, y2, y3, t);
    var dx = x - px;
    var dy = y - py;
    d += Math.sqrt(dx * dx + dy * dy);
    px = x;
    py = y;
  }
  return d;
}
function rotate(out, a, rad) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var st = Math.sin(rad);
  var ct = Math.cos(rad);
  out[0] = aa * ct + ab * st;
  out[1] = -aa * st + ab * ct;
  out[2] = ac * ct + ad * st;
  out[3] = -ac * st + ct * ad;
  out[4] = ct * atx + st * aty;
  out[5] = ct * aty - st * atx;
  return out;
}
function isAroundEqual(a, b) {
  return Math.abs(a[0] - b[0]) < 1e-8 && Math.abs(a[1] - b[1]) < 1e-8;
}
function getTransformMatrix(m, x, y, rot, scaleX, scaleY, anchorX, anchorY) {
  m[4] = -anchorX || 0;
  m[5] = -anchorY || 0;
  m[0] = scaleX == null ? 1 : scaleX;
  m[3] = scaleY == null ? 1 : scaleY;
  mat[1] = mat[2] = 0;
  rot && rotate(m, m, rot);
  m[4] += x;
  m[5] += y;
  return m;
}
function transformPts(out, pts, transform) {
  for (let i = 0; i < pts.length; i++) {
    pts[i] = pts[i];
    out[i] = out[i] || [];
    applyTransform(out[i], pts[i], transform);
  }
}
const defaultShapeRepeat = {
  repeat: 0,
  repeatX: 0,
  repeatY: 0,
  repeatRot: 0,
  repeatScaleX: 1,
  repeatScaleY: 1,
  repeatAnchorX: 0,
  repeatAnchorY: 0
};
let mat = [];
function withRepeat(buildPath, shape, ctx) {
  buildPath(ctx, shape, void 0);
  let x = 0;
  let y = 0;
  let rot = 0;
  let scaleX = 1;
  let scaleY = 1;
  for (let i = 0; i < shape.repeat; i++) {
    x += shape.repeatX;
    y += shape.repeatY;
    rot += shape.repeatRot;
    scaleX *= shape.repeatScaleX;
    scaleY *= shape.repeatScaleY;
    getTransformMatrix(mat, x, y, rot, scaleX, scaleY, shape.repeatAnchorX, shape.repeatAnchorY);
    buildPath(ctx, shape, mat);
  }
}
function eachSegment(inPts, outPts, vPts, close, drawSeg) {
  const len = vPts.length;
  if (!len) {
    return;
  }
  for (let i = 1; i < len; i++) {
    const prev = i - 1;
    if (!isAroundEqual(outPts[prev], vPts[prev]) || !isAroundEqual(inPts[i], vPts[i])) {
      drawSeg(vPts[prev], outPts[prev], inPts[i], vPts[i]);
    } else {
      drawSeg(vPts[prev], vPts[i]);
    }
  }
  if (close) {
    const last = len - 1;
    if (!isAroundEqual(outPts[last], vPts[last]) || !isAroundEqual(inPts[0], vPts[0])) {
      drawSeg(vPts[last], outPts[last], inPts[0], vPts[0]);
    } else {
      drawSeg(vPts[last], vPts[0]);
    }
  }
}
function buildCustomPath(ctx, shape, transform) {
  let trimStart = shape.trimStart / 100;
  let trimEnd = shape.trimEnd / 100;
  if (trimStart === trimEnd) {
    return;
  }
  if (trimStart > trimEnd) {
    const tmp = trimStart;
    trimStart = trimEnd;
    trimEnd = tmp;
  }
  let inPts;
  let outPts;
  let vPts;
  if (transform) {
    inPts = this._inPts || (this._inPts = []);
    outPts = this._outPts || (this._outPts = []);
    vPts = this._vPts || (this._vPts = []);
    transformPts(inPts, shape.in, transform);
    transformPts(outPts, shape.out, transform);
    transformPts(vPts, shape.v, transform);
  } else {
    inPts = shape.in;
    outPts = shape.out;
    vPts = shape.v;
  }
  if (trimStart > 0 || trimEnd < 1) {
    let segLens = [];
    let totalLen = 0;
    let idx = 0;
    eachSegment(inPts, outPts, vPts, false, (pt0, pt1, pt2, pt3) => {
      const segLen = pt2 && pt3 ? cubicLength(pt0[0], pt0[1], pt1[0], pt1[1], pt2[0], pt2[1], pt3[0], pt3[1], 10) : Math.sqrt((pt0[0] - pt1[0]) ** 2 + (pt0[1] - pt1[1]) ** 2);
      segLens[idx++] = segLen;
      totalLen += segLen;
    });
    const trimedStartLen = trimStart * totalLen;
    const trimedEndLen = trimEnd * totalLen;
    let currLen = 0;
    let segIdx = 0;
    eachSegment(inPts, outPts, vPts, false, (pt0, pt1, pt2, pt3) => {
      const segLen = segLens[segIdx];
      if (currLen + segLen <= trimedStartLen || currLen >= trimedEndLen) {
        return;
      } else if (currLen >= trimedStartLen && currLen + segLen <= trimedEndLen) {
        if (segIdx === 0) {
          ctx.moveTo(pt0[0], pt0[1]);
        }
        if (pt2 && pt3) {
          ctx.bezierCurveTo(pt1[0], pt1[1], pt2[0], pt2[1], pt3[0], pt3[1]);
        } else {
          ctx.lineTo(pt1[0], pt1[1]);
        }
      } else {
        const t0 = (trimedStartLen - currLen) / segLen;
        const t1 = (trimedEndLen - currLen) / segLen;
        if (t0 >= t1) {
          return;
        }
        let x0 = pt0[0];
        let y0 = pt0[1];
        let x1 = pt1[0];
        let y1 = pt1[1];
        if (pt2 && pt3) {
          let x2 = pt2[0];
          let y2 = pt2[1];
          let x3 = pt3[0];
          let y3 = pt3[1];
          const tmpX = [];
          const tmpY = [];
          if (t0 > 0) {
            cubicSubdivide(x0, x1, x2, x3, t0, tmpX);
            cubicSubdivide(y0, y1, y2, y3, t0, tmpY);
            x0 = tmpX[4];
            y0 = tmpY[4];
            x1 = tmpX[5];
            y1 = tmpY[5];
            x2 = tmpX[6];
            y2 = tmpY[6];
            x3 = tmpX[7];
            y3 = tmpY[7];
          }
          if (t1 < 1) {
            cubicSubdivide(x0, x1, x2, x3, t1, tmpX);
            cubicSubdivide(y0, y1, y2, y3, t1, tmpY);
            x0 = tmpX[0];
            y0 = tmpY[0];
            x1 = tmpX[1];
            y1 = tmpY[1];
            x2 = tmpX[2];
            y2 = tmpY[2];
            x3 = tmpX[3];
            y3 = tmpY[3];
          }
          ctx.moveTo(x0, y0);
          ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        } else {
          if (t0 > 0) {
            x0 = (x1 - x0) * t0 + x0;
            y0 = (y1 - y0) * t0 + y0;
          }
          if (t1 < 1) {
            x1 = (x1 - x0) * t1 + x0;
            y1 = (y1 - y0) * t1 + y0;
          }
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
        }
      }
      currLen += segLen;
      segIdx++;
    });
  } else {
    let isFirst = true;
    eachSegment(inPts, outPts, vPts, shape.close, (pt0, pt1, pt2, pt3) => {
      if (isFirst) {
        ctx.moveTo(pt0[0], pt0[1]);
      }
      if (pt2 && pt3) {
        ctx.bezierCurveTo(pt1[0], pt1[1], pt2[0], pt2[1], pt3[0], pt3[1]);
      } else {
        ctx.lineTo(pt1[0], pt1[1]);
      }
      isFirst = false;
    });
    if (shape.close) {
      ctx.closePath();
    }
  }
}
function install(echarts) {
  const LottieShapePath = echarts.graphic.extendShape({
    type: "lottie-shape-path",
    shape: __spreadValues({
      in: [],
      out: [],
      v: [],
      close: false,
      trimStart: 0,
      trimEnd: 100
    }, defaultShapeRepeat),
    buildPath(ctx, shape) {
      withRepeat((ctx2, shape2, transform) => {
        buildCustomPath.call(this, ctx2, shape2, transform);
      }, shape, ctx);
    }
  });
  const LottieShapeEllipse = echarts.graphic.extendShape({
    type: "lottie-shape-ellipse",
    shape: __spreadValues({
      cx: 0,
      cy: 0,
      rx: 0,
      ry: 0
    }, defaultShapeRepeat),
    buildPath(ctx, shape) {
      withRepeat((ctx2, shape2) => {
        let x = shape2.cx;
        let y = shape2.cy;
        let a = shape2.rx;
        let b = shape2.ry;
        if (a === b) {
          ctx2.arc(x, y, a, 0, Math.PI * 2);
          ctx2.closePath();
        } else {
          const k = 0.5522848;
          const ox = a * k;
          const oy = b * k;
          ctx2.moveTo(x - a, y);
          ctx2.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
          ctx2.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
          ctx2.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
          ctx2.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
          ctx2.closePath();
        }
      }, shape, ctx);
    }
  });
  const LottieShapeRect = echarts.graphic.extendShape({
    type: "lottie-shape-rect",
    shape: __spreadValues({
      r: 0,
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }, defaultShapeRepeat),
    buildPath(ctx, shape) {
      withRepeat((ctx2, shape2) => {
        let width = shape2.width;
        let height = shape2.height;
        let x = shape2.x - width / 2;
        let y = shape2.y - height / 2;
        let r = shape2.r;
        r = Math.min(width / 2, height / 2, r);
        if (!r) {
          ctx2.rect(x, y, width, height);
        } else {
          if (width < 0) {
            x = x + width;
            width = -width;
          }
          if (height < 0) {
            y = y + height;
            height = -height;
          }
          ctx2.moveTo(x + r, y);
          ctx2.lineTo(x + width - r, y);
          ctx2.arc(x + width - r, y + r, r, -Math.PI / 2, 0);
          ctx2.lineTo(x + width, y + height - r);
          ctx2.arc(x + width - r, y + height - r, r, 0, Math.PI / 2);
          ctx2.lineTo(x + r, y + height);
          ctx2.arc(x + r, y + height - r, r, Math.PI / 2, Math.PI);
          ctx2.lineTo(x, y + r);
          ctx2.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5);
          ctx2.closePath();
        }
      }, shape, ctx);
    }
  });
  echarts.graphic.registerShape("lottie-shape-path", LottieShapePath);
  echarts.graphic.registerShape("lottie-shape-ellipse", LottieShapeEllipse);
  echarts.graphic.registerShape("lottie-shape-rect", LottieShapeRect);
}
function completeLayers(layers, comps) {
  var layerData;
  var i;
  var len = layers.length;
  var j;
  var jLen;
  var k;
  var kLen;
  for (i = 0; i < len; i += 1) {
    layerData = layers[i];
    if ("ks" in layerData && !layerData.completed) {
      layerData.completed = true;
      if (layerData.tt) {
        layers[i - 1].td = layerData.tt;
      }
      if (layerData.hasMask) {
        var maskProps = layerData.masksProperties;
        jLen = maskProps.length;
        for (j = 0; j < jLen; j += 1) {
          if (maskProps[j].pt.k.i) {
            convertPathsToAbsoluteValues(maskProps[j].pt.k);
          } else {
            kLen = maskProps[j].pt.k.length;
            for (k = 0; k < kLen; k += 1) {
              if (maskProps[j].pt.k[k].s) {
                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
              }
              if (maskProps[j].pt.k[k].e) {
                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
              }
            }
          }
        }
      }
      if (layerData.ty === 0) {
        layerData.layers = findCompLayers(layerData.refId, comps);
        completeLayers(layerData.layers, comps);
      } else if (layerData.ty === 4) {
        completeShapes(layerData.shapes);
      } else if (layerData.ty === 5) {
        completeText(layerData);
      }
    }
  }
}
function findCompLayers(id, comps) {
  var i = 0;
  var len = comps.length;
  while (i < len) {
    if (comps[i].id === id) {
      if (!comps[i].layers.__used) {
        comps[i].layers.__used = true;
        return comps[i].layers;
      }
      return JSON.parse(JSON.stringify(comps[i].layers));
    }
    i += 1;
  }
  return null;
}
function completeShapes(arr) {
  var i;
  var len = arr.length;
  var j;
  var jLen;
  for (i = len - 1; i >= 0; i -= 1) {
    if (arr[i].ty === "sh") {
      if (arr[i].ks.k.i) {
        convertPathsToAbsoluteValues(arr[i].ks.k);
      } else {
        jLen = arr[i].ks.k.length;
        for (j = 0; j < jLen; j += 1) {
          if (arr[i].ks.k[j].s) {
            convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
          }
          if (arr[i].ks.k[j].e) {
            convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
          }
        }
      }
    } else if (arr[i].ty === "gr") {
      completeShapes(arr[i].it);
    }
  }
}
function convertPathsToAbsoluteValues(path) {
  var i;
  var len = path.i.length;
  for (i = 0; i < len; i += 1) {
    path.i[i][0] += path.v[i][0];
    path.i[i][1] += path.v[i][1];
    path.o[i][0] += path.v[i][0];
    path.o[i][1] += path.v[i][1];
  }
}
function checkVersion(minimum, animVersionString) {
  var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
  if (minimum[0] > animVersion[0]) {
    return true;
  }
  if (animVersion[0] > minimum[0]) {
    return false;
  }
  if (minimum[1] > animVersion[1]) {
    return true;
  }
  if (animVersion[1] > minimum[1]) {
    return false;
  }
  if (minimum[2] > animVersion[2]) {
    return true;
  }
  if (animVersion[2] > minimum[2]) {
    return false;
  }
  return null;
}
var checkText = function() {
  var minimumVersion = [4, 4, 14];
  function updateTextLayer(textLayer) {
    var documentData = textLayer.t.d;
    textLayer.t.d = {
      k: [
        {
          s: documentData,
          t: 0
        }
      ]
    };
  }
  function iterateLayers(layers) {
    var i;
    var len = layers.length;
    for (i = 0; i < len; i += 1) {
      if (layers[i].ty === 5) {
        updateTextLayer(layers[i]);
      }
    }
  }
  return function(animationData) {
    if (checkVersion(minimumVersion, animationData.v)) {
      iterateLayers(animationData.layers);
      if (animationData.assets) {
        var i;
        var len = animationData.assets.length;
        for (i = 0; i < len; i += 1) {
          if (animationData.assets[i].layers) {
            iterateLayers(animationData.assets[i].layers);
          }
        }
      }
    }
  };
}();
var checkChars = function() {
  var minimumVersion = [4, 7, 99];
  return function(animationData) {
    if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
      var i;
      var len = animationData.chars.length;
      var j;
      var jLen;
      var pathData;
      var paths;
      for (i = 0; i < len; i += 1) {
        if (animationData.chars[i].data && animationData.chars[i].data.shapes) {
          paths = animationData.chars[i].data.shapes[0].it;
          jLen = paths.length;
          for (j = 0; j < jLen; j += 1) {
            pathData = paths[j].ks.k;
            if (!pathData.__converted) {
              convertPathsToAbsoluteValues(paths[j].ks.k);
              pathData.__converted = true;
            }
          }
        }
      }
    }
  };
}();
var checkPathProperties = function() {
  var minimumVersion = [5, 7, 15];
  function updateTextLayer(textLayer) {
    var pathData = textLayer.t.p;
    if (typeof pathData.a === "number") {
      pathData.a = {
        a: 0,
        k: pathData.a
      };
    }
    if (typeof pathData.p === "number") {
      pathData.p = {
        a: 0,
        k: pathData.p
      };
    }
    if (typeof pathData.r === "number") {
      pathData.r = {
        a: 0,
        k: pathData.r
      };
    }
  }
  function iterateLayers(layers) {
    var i;
    var len = layers.length;
    for (i = 0; i < len; i += 1) {
      if (layers[i].ty === 5) {
        updateTextLayer(layers[i]);
      }
    }
  }
  return function(animationData) {
    if (checkVersion(minimumVersion, animationData.v)) {
      iterateLayers(animationData.layers);
      if (animationData.assets) {
        var i;
        var len = animationData.assets.length;
        for (i = 0; i < len; i += 1) {
          if (animationData.assets[i].layers) {
            iterateLayers(animationData.assets[i].layers);
          }
        }
      }
    }
  };
}();
var checkColors = function() {
  var minimumVersion = [4, 1, 9];
  function iterateShapes(shapes) {
    var i;
    var len = shapes.length;
    var j;
    var jLen;
    for (i = 0; i < len; i += 1) {
      if (shapes[i].ty === "gr") {
        iterateShapes(shapes[i].it);
      } else if (shapes[i].ty === "fl" || shapes[i].ty === "st") {
        if (shapes[i].c.k && shapes[i].c.k[0].i) {
          jLen = shapes[i].c.k.length;
          for (j = 0; j < jLen; j += 1) {
            if (shapes[i].c.k[j].s) {
              shapes[i].c.k[j].s[0] /= 255;
              shapes[i].c.k[j].s[1] /= 255;
              shapes[i].c.k[j].s[2] /= 255;
              shapes[i].c.k[j].s[3] /= 255;
            }
            if (shapes[i].c.k[j].e) {
              shapes[i].c.k[j].e[0] /= 255;
              shapes[i].c.k[j].e[1] /= 255;
              shapes[i].c.k[j].e[2] /= 255;
              shapes[i].c.k[j].e[3] /= 255;
            }
          }
        } else {
          shapes[i].c.k[0] /= 255;
          shapes[i].c.k[1] /= 255;
          shapes[i].c.k[2] /= 255;
          shapes[i].c.k[3] /= 255;
        }
      }
    }
  }
  function iterateLayers(layers) {
    var i;
    var len = layers.length;
    for (i = 0; i < len; i += 1) {
      if (layers[i].ty === 4) {
        iterateShapes(layers[i].shapes);
      }
    }
  }
  return function(animationData) {
    if (checkVersion(minimumVersion, animationData.v)) {
      iterateLayers(animationData.layers);
      if (animationData.assets) {
        var i;
        var len = animationData.assets.length;
        for (i = 0; i < len; i += 1) {
          if (animationData.assets[i].layers) {
            iterateLayers(animationData.assets[i].layers);
          }
        }
      }
    }
  };
}();
var checkShapes = function() {
  var minimumVersion = [4, 4, 18];
  function completeClosingShapes(arr) {
    var i;
    var len = arr.length;
    var j;
    var jLen;
    for (i = len - 1; i >= 0; i -= 1) {
      if (arr[i].ty === "sh") {
        if (arr[i].ks.k.i) {
          arr[i].ks.k.c = arr[i].closed;
        } else {
          jLen = arr[i].ks.k.length;
          for (j = 0; j < jLen; j += 1) {
            if (arr[i].ks.k[j].s) {
              arr[i].ks.k[j].s[0].c = arr[i].closed;
            }
            if (arr[i].ks.k[j].e) {
              arr[i].ks.k[j].e[0].c = arr[i].closed;
            }
          }
        }
      } else if (arr[i].ty === "gr") {
        completeClosingShapes(arr[i].it);
      }
    }
  }
  function iterateLayers(layers) {
    var layerData;
    var i;
    var len = layers.length;
    var j;
    var jLen;
    var k;
    var kLen;
    for (i = 0; i < len; i += 1) {
      layerData = layers[i];
      if (layerData.hasMask) {
        var maskProps = layerData.masksProperties;
        jLen = maskProps.length;
        for (j = 0; j < jLen; j += 1) {
          if (maskProps[j].pt.k.i) {
            maskProps[j].pt.k.c = maskProps[j].cl;
          } else {
            kLen = maskProps[j].pt.k.length;
            for (k = 0; k < kLen; k += 1) {
              if (maskProps[j].pt.k[k].s) {
                maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
              }
              if (maskProps[j].pt.k[k].e) {
                maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
              }
            }
          }
        }
      }
      if (layerData.ty === 4) {
        completeClosingShapes(layerData.shapes);
      }
    }
  }
  return function(animationData) {
    if (checkVersion(minimumVersion, animationData.v)) {
      iterateLayers(animationData.layers);
      if (animationData.assets) {
        var i;
        var len = animationData.assets.length;
        for (i = 0; i < len; i += 1) {
          if (animationData.assets[i].layers) {
            iterateLayers(animationData.assets[i].layers);
          }
        }
      }
    }
  };
}();
function completeData(animationData) {
  if (animationData.__complete) {
    return;
  }
  checkColors(animationData);
  checkText(animationData);
  checkChars(animationData);
  checkPathProperties(animationData);
  checkShapes(animationData);
  completeLayers(animationData.layers, animationData.assets);
  animationData.__complete = true;
}
function completeText(data) {
  if (data.t.a.length === 0 && !("m" in data.t.p)) {
    data.singleShape = true;
  }
}
class ParseContext {
  constructor() {
    __publicField(this, "frameTime", 1e3 / 30);
    __publicField(this, "startFrame", 0);
    __publicField(this, "endFrame");
    __publicField(this, "assetsMap", new Map());
    __publicField(this, "layerOffsetTime");
  }
}
function isNumberArray(val) {
  return Array.isArray(val) && typeof val[0] === "number";
}
function isMultiDimensionalValue(val) {
  return isNumberArray(val == null ? void 0 : val.k);
}
function isMultiDimensionalKeyframedValue(val) {
  const k = val == null ? void 0 : val.k;
  return Array.isArray(k) && k[0].t !== void 0 && isNumberArray(k[0].s);
}
function isValue(val) {
  return typeof (val == null ? void 0 : val.k) === "number";
}
function isKeyframedValue(val) {
  const k = val == null ? void 0 : val.k;
  return Array.isArray(k) && k[0].t !== void 0 && typeof k[0].s === "number";
}
function toColorString(val) {
  return `rgba(${[
    Math.round(getMultiDimensionValue(val, 0) * 255),
    Math.round(getMultiDimensionValue(val, 1) * 255),
    Math.round(getMultiDimensionValue(val, 2) * 255),
    getMultiDimensionValue(val, 3)
  ].join(",")})`;
}
function getMultiDimensionValue(val, dimIndex) {
  return val != null ? typeof val === "number" ? val : val[dimIndex || 0] : NaN;
}
function getMultiDimensionEasingBezierString(kf, nextKf, dimIndex) {
  var _a, _b, _c, _d;
  let bezierEasing = [];
  bezierEasing.push(((_a = kf.o) == null ? void 0 : _a.x) ? getMultiDimensionValue(kf.o.x, dimIndex) : 0, ((_b = kf.o) == null ? void 0 : _b.y) ? getMultiDimensionValue(kf.o.y, dimIndex) : 0, ((_c = nextKf == null ? void 0 : nextKf.o) == null ? void 0 : _c.x) ? getMultiDimensionValue(nextKf.o.x, dimIndex) : 1, ((_d = nextKf == null ? void 0 : nextKf.o) == null ? void 0 : _d.y) ? getMultiDimensionValue(nextKf.o.y, dimIndex) : 1);
  if (bezierEasing[0] && bezierEasing[1] && bezierEasing[2] !== 1 && bezierEasing[3] !== 1) {
    return `cubic-bezier(${bezierEasing.join(",")})`;
  }
  return;
}
function parseKeyframe(kfs, bezierEasingDimIndex, context, setVal) {
  const kfsLen = kfs.length;
  const duration = context.endFrame - context.startFrame;
  const out = {
    duration: 0,
    delay: 0,
    keyframes: []
  };
  let prevKf;
  for (let i = 0; i < kfsLen; i++) {
    const kf = kfs[i];
    const nextKf = kfs[i + 1];
    const isDiscrete = kf.h === 1;
    const percent = (kf.t + context.layerOffsetTime - context.startFrame) / duration;
    const outKeyframe = {
      percent
    };
    if (!isDiscrete) {
      outKeyframe.easing = getMultiDimensionEasingBezierString(kf, nextKf, bezierEasingDimIndex);
    }
    const startVal = kf.s || (prevKf == null ? void 0 : prevKf.e);
    if (startVal) {
      setVal(outKeyframe, startVal);
    }
    if (outKeyframe.percent > 0 && i === 0) {
      const initialKeyframe = {
        percent: 0
      };
      if (startVal) {
        setVal(initialKeyframe, startVal);
      }
      out.keyframes.push(initialKeyframe);
    }
    out.keyframes.push(outKeyframe);
    if (isDiscrete && nextKf) {
      const extraKeyframe = {
        percent: Math.max((nextKf.t + context.layerOffsetTime - context.startFrame) / duration, 0)
      };
      setVal(extraKeyframe, startVal);
      out.keyframes.push(extraKeyframe);
    }
    prevKf = kf;
  }
  if (kfsLen) {
    out.duration = context.frameTime * duration;
  }
  return out;
}
function parseOffsetKeyframe(kfs, targetPropName, propNames, keyframeAnimations, context, convertVal) {
  for (let dimIndex = 0; dimIndex < propNames.length; dimIndex++) {
    const propName = propNames[dimIndex];
    const keyframeAnim = parseKeyframe(kfs, dimIndex, context, (outKeyframe, startVal) => {
      let val = getMultiDimensionValue(startVal, dimIndex);
      if (convertVal) {
        val = convertVal(val);
      }
      (targetPropName ? outKeyframe[targetPropName] = {} : outKeyframe)[propName] = val;
    });
    if (keyframeAnim.keyframes.length) {
      keyframeAnimations.push(keyframeAnim);
    }
  }
}
function parseColorOffsetKeyframe(kfs, targetPropName, propName, keyframeAnimations, context) {
  const keyframeAnim = parseKeyframe(kfs, 0, context, (outKeyframe, startVal) => {
    (targetPropName ? outKeyframe[targetPropName] = {} : outKeyframe)[propName] = toColorString(startVal);
  });
  if (keyframeAnim.keyframes.length) {
    keyframeAnimations.push(keyframeAnim);
  }
}
function parseValue(lottieVal, attrs, targetPropName, propNames, animations, context, convertVal) {
  if (targetPropName) {
    attrs[targetPropName] = attrs[targetPropName] || {};
  }
  const target = targetPropName ? attrs[targetPropName] : attrs;
  if (isValue(lottieVal)) {
    const val = lottieVal.k;
    target[propNames[0]] = convertVal ? convertVal(val) : val;
  } else if (isKeyframedValue(lottieVal)) {
    parseOffsetKeyframe(lottieVal.k, targetPropName, propNames, animations, context, convertVal);
  } else if (isMultiDimensionalValue(lottieVal)) {
    for (let i = 0; i < propNames.length; i++) {
      const val = getMultiDimensionValue(lottieVal.k, i);
      target[propNames[i]] = convertVal ? convertVal(val) : val;
    }
  } else if (isMultiDimensionalKeyframedValue(lottieVal)) {
    parseOffsetKeyframe(lottieVal.k, targetPropName, propNames, animations, context, convertVal);
  }
}
function parseTransforms(ks, attrs, animations, context, targetProp = "", transformProps = {
  x: "x",
  y: "y",
  rotation: "rotation",
  scaleX: "scaleX",
  scaleY: "scaleY",
  anchorX: "anchorX",
  anchorY: "anchorY"
}) {
  if (ks.p.s) {
    parseValue(ks.p.x, attrs, targetProp, [transformProps.x], animations, context);
    parseValue(ks.p.y, attrs, targetProp, [transformProps.y], animations, context);
  } else {
    parseValue(ks.p, attrs, targetProp, [transformProps.x, transformProps.y], animations, context);
  }
  parseValue(ks.s, attrs, targetProp, [transformProps.scaleX, transformProps.scaleY], animations, context, (val) => val / 100);
  parseValue(ks.r, attrs, targetProp, [transformProps.rotation], animations, context, (val) => -(val / 180) * Math.PI);
  parseValue(ks.a, attrs, targetProp, [transformProps.anchorX, transformProps.anchorY], animations, context);
}
function isGradientFillOrStroke(fl) {
  return fl.g && fl.s && fl.e;
}
function convertColorStops(arr, count) {
  const colorStops = [];
  for (let i = 0; i < count * 4; ) {
    const offset = arr[i++];
    const r = Math.round(arr[i++] * 255);
    const g = Math.round(arr[i++] * 255);
    const b = Math.round(arr[i++] * 255);
    colorStops.push({
      offset,
      color: `rgb(${r}, ${g}, ${b})`
    });
  }
  return colorStops;
}
function parseGradient(shape) {
  const colorArr = shape.g.k.k;
  const colorStops = convertColorStops(colorArr, shape.g.p);
  if (shape.t === GradientType.Linear) {
    return {
      type: "linear",
      colorStops,
      x: shape.s.k[0],
      y: shape.s.k[1],
      x2: shape.e.k[0],
      y2: shape.e.k[1],
      global: true
    };
  } else if (shape.t === GradientType.Radial) {
    return {
      type: "radial",
      colorStops,
      x: shape.s.k[0],
      y: shape.s.k[1],
      r: dist(shape.e.k, shape.s.k),
      global: true
    };
  } else {
    return "#000";
  }
}
function parseFill(fl, attrs, animations, context) {
  attrs.style = attrs.style || {};
  if (isGradientFillOrStroke(fl)) {
    attrs.style.fill = parseGradient(fl);
  } else {
    if (isMultiDimensionalValue(fl.c)) {
      attrs.style.fill = toColorString(fl.c.k);
    } else if (isMultiDimensionalKeyframedValue(fl.c)) {
      parseColorOffsetKeyframe(fl.c.k, "style", "fill", animations, context);
    }
  }
  parseValue(fl.o, attrs, "style", ["fillOpacity"], animations, context, (opacity) => opacity / 100);
}
function parseStroke(st, attrs, animations, context) {
  attrs.style = attrs.style || {};
  if (isGradientFillOrStroke(st)) {
    attrs.style.stroke = parseGradient(st);
  } else {
    if (isMultiDimensionalValue(st.c)) {
      attrs.style.stroke = toColorString(st.c.k);
    } else if (isMultiDimensionalKeyframedValue(st.c)) {
      parseColorOffsetKeyframe(st.c.k, "style", "stroke", animations, context);
    }
  }
  parseValue(st.o, attrs, "style", ["strokeOpacity"], animations, context, (opacity) => opacity / 100);
  parseValue(st.w, attrs, "style", ["lineWidth"], animations, context);
  switch (st.lj) {
    case LineJoin.Bevel:
      attrs.style.lineJoin = "bevel";
      break;
    case LineJoin.Round:
      attrs.style.lineJoin = "round";
      break;
    case LineJoin.Miter:
      attrs.style.lineJoin = "miter";
      break;
  }
  switch (st.lc) {
    case LineCap.Butt:
      attrs.style.lineCap = "butt";
      break;
    case LineCap.Round:
      attrs.style.lineCap = "round";
      break;
    case LineCap.Square:
      attrs.style.lineCap = "square";
      break;
  }
  const dashArray = [];
  let dashOffset = 0;
  if (st.d) {
    st.d.forEach((item) => {
      if (item.n !== "o") {
        dashArray.push(item.v.k);
      } else {
        dashOffset = item.v.k;
      }
    });
    attrs.style.lineDash = dashArray;
    attrs.style.lineDashOffset = dashOffset;
  }
}
function isBezier(k) {
  return k && k.i && k.o && k.v;
}
function parseShapePaths(shape, animations, context) {
  const attrs = {
    type: "lottie-shape-path",
    style: {
      fill: "none",
      stroke: "none"
    }
  };
  if (isBezier(shape.ks.k)) {
    attrs.shape = {
      in: shape.ks.k.i,
      out: shape.ks.k.o,
      v: shape.ks.k.v,
      close: shape.ks.k.c
    };
  } else if (Array.isArray(shape.ks.k)) {
    const keyframeAnim = parseKeyframe(shape.ks.k, 0, context, (outKeyframe, startVal) => {
      outKeyframe.shape = {
        in: startVal[0].i,
        out: startVal[0].o,
        v: startVal[0].v,
        close: startVal[0].c
      };
    });
    if (keyframeAnim.keyframes.length) {
      animations.push(keyframeAnim);
    }
  }
  return attrs;
}
function parseShapeRect(shape, animations, context) {
  const attrs = {
    type: "lottie-shape-rect",
    style: {
      fill: "none",
      stroke: "none"
    },
    shape: {}
  };
  parseValue(shape.p, attrs, "shape", ["x", "y"], animations, context);
  parseValue(shape.s, attrs, "shape", ["width", "height"], animations, context);
  parseValue(shape.r, attrs, "shape", ["r"], animations, context);
  return attrs;
}
function parseShapeEllipse(shape, animations, context) {
  const attrs = {
    type: "lottie-shape-ellipse",
    style: {
      fill: "none",
      stroke: "none"
    },
    shape: {}
  };
  parseValue(shape.p, attrs, "shape", ["cx", "cy"], animations, context);
  parseValue(shape.s, attrs, "shape", ["rx", "ry"], animations, context, (val) => val / 2);
  return attrs;
}
function parseShapeLayer(layer, context) {
  function tryCreateShape(shape, keyframeAnimations) {
    let ecEl;
    switch (shape.ty) {
      case ShapeType.Path:
        ecEl = parseShapePaths(shape, keyframeAnimations, context);
        break;
      case ShapeType.Ellipse:
        ecEl = parseShapeEllipse(shape, keyframeAnimations, context);
        break;
      case ShapeType.Rect:
        ecEl = parseShapeRect(shape, keyframeAnimations, context);
        break;
    }
    return ecEl;
  }
  function parseModifiers(shapes, modifiers) {
    shapes.forEach((shape) => {
      if (shape.hd) {
        return;
      }
      switch (shape.ty) {
        case ShapeType.Repeat:
          parseValue(shape.c, modifiers.attrs, "shape", ["repeat"], modifiers.keyframeAnimations, context);
          parseTransforms(shape.tr, modifiers.attrs, modifiers.keyframeAnimations, context, "shape", {
            x: "repeatX",
            y: "repeatY",
            rotation: "repeatRot",
            scaleX: "repeatScaleX",
            scaleY: "repeatScaleY",
            anchorX: "repeatAnchorX",
            anchorY: "repeatAnchorY"
          });
          break;
        case ShapeType.Trim:
          parseValue(shape.s, modifiers.attrs, "shape", ["trimStart"], modifiers.keyframeAnimations, context);
          parseValue(shape.e, modifiers.attrs, "shape", ["trimEnd"], modifiers.keyframeAnimations, context);
          break;
      }
    });
  }
  function parseIterations(shapes, modifiers) {
    const ecEls = [];
    const attrs = {};
    const keyframeAnimations = [];
    shapes = shapes.slice().reverse();
    parseModifiers(shapes, modifiers);
    shapes.forEach((shape) => {
      if (shape.hd) {
        return;
      }
      let ecEl;
      switch (shape.ty) {
        case ShapeType.Group:
          ecEl = {
            type: "group",
            children: parseIterations(shape.it, modifiers)
          };
          break;
        case ShapeType.Fill:
        case ShapeType.GradientFill:
          parseFill(shape, attrs, keyframeAnimations, context);
          break;
        case ShapeType.Stroke:
        case ShapeType.GradientStroke:
          parseStroke(shape, attrs, keyframeAnimations, context);
          break;
        case ShapeType.Transform:
          parseTransforms(shape, attrs, keyframeAnimations, context);
          break;
        default:
          ecEl = tryCreateShape(shape, keyframeAnimations);
      }
      if (ecEl) {
        ecEl.name = shape.nm;
        ecEls.push(ecEl);
      }
    });
    ecEls.forEach((el, idx) => {
      merge(el, modifiers.attrs, true);
      merge(el, attrs, true);
      if (keyframeAnimations.length || modifiers.keyframeAnimations.length) {
        el.keyframeAnimation = [
          ...modifiers.keyframeAnimations,
          ...keyframeAnimations
        ];
      }
      ecEls[idx] = el;
    });
    return ecEls;
  }
  return {
    type: "group",
    children: parseIterations(layer.shapes, {
      attrs: {},
      keyframeAnimations: []
    })
  };
}
function traverse(el, cb) {
  var _a;
  cb(el);
  if (el.type === "group") {
    (_a = el.children) == null ? void 0 : _a.forEach((child) => {
      traverse(child, cb);
    });
  }
}
function addLayerOpacity(layer, layerGroup, context) {
  var _a, _b;
  const opacityAttrs = {};
  const opacityAnimations = [];
  if ((_a = layer.ks) == null ? void 0 : _a.o) {
    parseValue(layer.ks.o, opacityAttrs, "style", ["opacity"], opacityAnimations, context, (val) => val / 100);
    if (((_b = opacityAttrs.style) == null ? void 0 : _b.opacity) || opacityAnimations.length) {
      traverse(layerGroup, (el) => {
        if (el.type !== "group" && el.style) {
          Object.assign(el.style, opacityAttrs.style);
          if (opacityAnimations.length) {
            el.keyframeAnimation = (el.keyframeAnimation || []).concat(opacityAnimations);
          }
        }
      });
    }
  }
}
function parseSolidShape(layer) {
  return {
    type: "rect",
    shape: {
      x: 0,
      y: 0,
      width: layer.sw,
      height: layer.sh
    },
    style: {
      fill: layer.sc
    }
  };
}
function parseLayers(layers, context, precompLayerTl) {
  let elements = [];
  layers = layers.slice().reverse();
  const layerIndexMap = new Map();
  const offsetTime = (precompLayerTl == null ? void 0 : precompLayerTl.st) || 0;
  layers == null ? void 0 : layers.forEach((layer) => {
    var _a, _b;
    const layerIp = offsetTime + layer.ip;
    const layerOp = offsetTime + layer.op;
    const layerSt = offsetTime + layer.st;
    context.layerOffsetTime = offsetTime;
    let layerGroup;
    switch (layer.ty) {
      case LayerType.shape:
        layerGroup = parseShapeLayer(layer, context);
        break;
      case LayerType.null:
        layerGroup = {
          type: "group",
          children: []
        };
        break;
      case LayerType.solid:
        layerGroup = {
          type: "group",
          children: []
        };
        if (layer.sc) {
          layerGroup.children.push(parseSolidShape(layer));
        }
        break;
      case LayerType.precomp:
        layerGroup = {
          type: "group",
          children: parseLayers(((_a = context.assetsMap.get(layer.refId)) == null ? void 0 : _a.layers) || [], context, {
            st: layerSt
          })
        };
        break;
    }
    if (layerGroup) {
      const keyframeAnimations = [];
      const attrs = {
        name: layer.nm
      };
      layer.ks && parseTransforms(layer.ks, attrs, keyframeAnimations, context);
      Object.assign(layerGroup, attrs);
      if (layer.ind != null) {
        layerIndexMap.set(layer.ind, layerGroup);
      }
      layerGroup.extra = {
        layerParent: layer.parent
      };
      if (layer.hasMask && ((_b = layer.masksProperties) == null ? void 0 : _b.length)) {
        const maskKeyframeAnimations = [];
        const attrs2 = parseShapePaths({
          ks: layer.masksProperties[0].pt
        }, maskKeyframeAnimations, context);
        layerGroup.clipPath = __spreadValues({
          type: "lottie-shape-path"
        }, attrs2);
        layerGroup.clipPath.style.fill = "#000";
        if (maskKeyframeAnimations.length) {
          layerGroup.clipPath.keyframeAnimation = maskKeyframeAnimations;
        }
      }
      addLayerOpacity(layer, layerGroup, context);
      if (layerIp != null && layerOp != null && (layerIp > context.startFrame || layerOp < context.endFrame)) {
        const duration = context.endFrame - context.startFrame;
        const enterAndLeaveAnim = {
          duration: duration * context.frameTime,
          keyframes: [
            {
              ignore: false,
              percent: (layerIp - context.startFrame) / duration
            }
          ]
        };
        if (layerIp > context.startFrame) {
          enterAndLeaveAnim.keyframes.unshift({
            ignore: true,
            percent: 0
          });
        }
        if ((layerOp - context.startFrame) / duration < 1) {
          enterAndLeaveAnim.keyframes.push({
            ignore: true,
            percent: (layerOp - context.startFrame) / duration
          });
        }
        keyframeAnimations.push(enterAndLeaveAnim);
      }
      if (keyframeAnimations.length) {
        layerGroup.keyframeAnimation = keyframeAnimations;
      }
      elements.push(layerGroup);
    }
  });
  return elements.filter((el) => {
    var _a, _b;
    const parentLayer = layerIndexMap.get((_a = el.extra) == null ? void 0 : _a.layerParent);
    if (parentLayer) {
      (_b = parentLayer.children) == null ? void 0 : _b.push(el);
      return false;
    }
    return true;
  });
}
function parse(data, opts) {
  var _a;
  completeData(data);
  const context = new ParseContext();
  opts = opts || {};
  context.frameTime = 1e3 / (data.fr || 30);
  context.startFrame = data.ip;
  context.endFrame = data.op;
  (_a = data.assets) == null ? void 0 : _a.forEach((asset) => {
    context.assetsMap.set(asset.id, asset);
  });
  const elements = parseLayers(data.layers || [], context);
  function eachElement(elements2, cb) {
    elements2.forEach((el) => {
      cb(el);
      if (el.children) {
        eachElement(el.children, cb);
      }
    });
  }
  if (opts.loop) {
    eachElement(elements, (el) => {
      var _a2;
      (_a2 = el.keyframeAnimation) == null ? void 0 : _a2.forEach((anim) => {
        anim.loop = true;
      });
    });
  }
  return {
    width: data.w,
    height: data.h,
    elements,
    each: (cb) => {
      eachElement(elements, cb);
    }
  };
}
export { install, parse };
